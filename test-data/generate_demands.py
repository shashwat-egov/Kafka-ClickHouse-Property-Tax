#!/usr/bin/env python3
"""
Generate 70,000 demand events and send to Kafka.

This script creates property tax demands for the properties generated by
generate_properties.py:
- 7 demands per property (FY 2018-19 through 2024-25)
- Each demand has 2-3 tax heads (PT_TAX, PT_LATE_FEE, PT_CESS)
- Initial collection_amount = 0 (unpaid)

Usage:
    python generate_demands.py [--bootstrap-servers localhost:29092]
"""

import argparse
import json
import random
import time
import uuid
from datetime import datetime
from kafka import KafkaProducer

# Configuration
NUM_PROPERTIES = 10000
DEMANDS_PER_PROPERTY = 7  # FY 2018-19 to 2024-25
KAFKA_TOPIC = "demand-events"

# Reference data
TENANTS = ["pb.amritsar", "pb.jalandhar", "pb.ludhiana", "pb.patiala"]

# Financial years: April 1 to March 31
FINANCIAL_YEARS = [
    ("2018-19", datetime(2018, 4, 1), datetime(2019, 3, 31)),
    ("2019-20", datetime(2019, 4, 1), datetime(2020, 3, 31)),
    ("2020-21", datetime(2020, 4, 1), datetime(2021, 3, 31)),
    ("2021-22", datetime(2021, 4, 1), datetime(2022, 3, 31)),
    ("2022-23", datetime(2022, 4, 1), datetime(2023, 3, 31)),
    ("2023-24", datetime(2023, 4, 1), datetime(2024, 3, 31)),
    ("2024-25", datetime(2024, 4, 1), datetime(2025, 3, 31)),
]

# Tax heads
TAX_HEADS = [
    ("PT_TAX", "Property Tax"),
    ("PT_LATE_FEE", "Late Payment Fee"),
    ("PT_CESS", "Education Cess"),
]

FIRST_NAMES = [
    "Rajesh", "Sunil", "Anil", "Vijay", "Sandeep",
    "Amit", "Deepak", "Rakesh", "Mukesh", "Manoj",
    "Priya", "Sunita", "Anita", "Kavita", "Neha",
]

LAST_NAMES = [
    "Singh", "Sharma", "Kumar", "Gupta", "Verma",
    "Kaur", "Gill", "Sidhu", "Dhillon", "Malhotra",
]


def datetime_to_millis(dt: datetime) -> int:
    """Convert datetime to milliseconds timestamp."""
    return int(dt.timestamp() * 1000)


def generate_demand_details(demand_id: str, fy_start: datetime) -> list:
    """Generate 2-3 tax heads for a demand."""
    # Always include PT_TAX, randomly include others
    tax_heads_to_use = [TAX_HEADS[0]]  # PT_TAX always
    if random.random() > 0.3:
        tax_heads_to_use.append(TAX_HEADS[1])  # PT_LATE_FEE 70%
    if random.random() > 0.5:
        tax_heads_to_use.append(TAX_HEADS[2])  # PT_CESS 50%

    details = []
    for tax_head_code, tax_head_name in tax_heads_to_use:
        # Base tax amount varies by tax head
        if tax_head_code == "PT_TAX":
            tax_amount = round(random.uniform(5000, 50000), 2)
        elif tax_head_code == "PT_LATE_FEE":
            tax_amount = round(random.uniform(100, 2000), 2)
        else:  # PT_CESS
            tax_amount = round(random.uniform(200, 3000), 2)

        details.append({
            "id": str(uuid.uuid4()),
            "taxHeadMasterCode": tax_head_code,
            "taxHeadMasterId": str(uuid.uuid4()),
            "taxAmount": str(tax_amount),
            "collectionAmount": "0",  # Initially unpaid
            "taxPeriodFrom": datetime_to_millis(fy_start),
            "taxPeriodTo": datetime_to_millis(
                datetime(fy_start.year + 1, 3, 31, 23, 59, 59)
            ),
        })

    return details


def generate_demand_event(
    property_index: int,
    tenant_id: str,
    property_id: str,
    fy_info: tuple,
) -> dict:
    """Generate a demand event for a property and financial year."""
    fy_name, fy_start, fy_end = fy_info
    demand_id = str(uuid.uuid4())

    # Demand created a few months into the financial year
    created_month = random.randint(4, 8)  # April to August
    created_dt = datetime(
        fy_start.year,
        created_month,
        random.randint(1, 28),
        random.randint(9, 17),
        random.randint(0, 59),
    )
    created_time = datetime_to_millis(created_dt)

    # Payer info
    first_name = random.choice(FIRST_NAMES)
    last_name = random.choice(LAST_NAMES)

    demand_details = generate_demand_details(demand_id, fy_start)

    # Calculate minimum payable (sum of all tax amounts)
    total_tax = sum(float(d["taxAmount"]) for d in demand_details)

    return {
        "tenantId": tenant_id,
        "demand": {
            "id": demand_id,
            "consumerCode": property_id,  # Links to property_id
            "consumerType": "PT",
            "businessService": "PT",
            "taxPeriodFrom": datetime_to_millis(fy_start),
            "taxPeriodTo": datetime_to_millis(fy_end),
            "billingPeriod": fy_name,
            "status": "ACTIVE",
            "isPaymentCompleted": False,
            "financialYear": fy_name,
            "minimumAmountPayable": str(round(total_tax, 2)),
            "payer": {
                "name": f"{first_name} {last_name}",
                "mobileNumber": f"98{random.randint(10000000, 99999999)}",
                "email": f"{first_name.lower()}.{last_name.lower()}@example.com",
            },
            "demandDetails": demand_details,
            "auditDetails": {
                "createdBy": "system",
                "createdTime": created_time,
                "lastModifiedBy": "system",
                "lastModifiedTime": created_time,
            },
            "version": 1,
        },
    }


def get_property_info(property_index: int) -> tuple:
    """Get tenant_id and property_id for a property index."""
    # Distribute properties across tenants
    tenant_index = property_index % len(TENANTS)
    tenant_id = TENANTS[tenant_index]
    property_id = f"PT-{tenant_id.split('.')[1].upper()}-{property_index:06d}"
    return tenant_id, property_id


def main():
    parser = argparse.ArgumentParser(description="Generate demand events to Kafka")
    parser.add_argument(
        "--bootstrap-servers",
        default="localhost:29092",
        help="Kafka bootstrap servers (default: localhost:29092)",
    )
    parser.add_argument(
        "--num-properties",
        type=int,
        default=NUM_PROPERTIES,
        help=f"Number of properties (default: {NUM_PROPERTIES})",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print events to stdout instead of sending to Kafka",
    )
    args = parser.parse_args()

    total_demands = args.num_properties * DEMANDS_PER_PROPERTY

    if args.dry_run:
        # Print sample events for first property
        tenant_id, property_id = get_property_info(1)
        for fy_info in FINANCIAL_YEARS[:2]:  # Just first 2 FYs
            event = generate_demand_event(1, tenant_id, property_id, fy_info)
            print(json.dumps(event, indent=2))
            print("---")
        print(f"[DRY RUN] Would generate {total_demands:,} demand events")
        print(f"  ({args.num_properties:,} properties x {DEMANDS_PER_PROPERTY} FYs)")
        return

    # Create Kafka producer
    producer = KafkaProducer(
        bootstrap_servers=args.bootstrap_servers,
        value_serializer=lambda v: json.dumps(v).encode("utf-8"),
        acks="all",
        retries=3,
    )

    print(f"Generating {total_demands:,} demand events...")
    print(f"  ({args.num_properties:,} properties x {DEMANDS_PER_PROPERTY} FYs)")
    start_time = time.time()

    event_count = 0
    for prop_idx in range(1, args.num_properties + 1):
        tenant_id, property_id = get_property_info(prop_idx)

        for fy_info in FINANCIAL_YEARS:
            event = generate_demand_event(prop_idx, tenant_id, property_id, fy_info)
            producer.send(KAFKA_TOPIC, value=event)
            event_count += 1

        if prop_idx % 1000 == 0:
            producer.flush()
            elapsed = time.time() - start_time
            rate = event_count / elapsed
            print(f"  Processed {prop_idx:,} properties, {event_count:,} demands ({rate:.0f} events/sec)")

    producer.flush()
    producer.close()

    elapsed = time.time() - start_time
    print(f"Completed: {event_count:,} demand events in {elapsed:.1f}s")
    print(f"Rate: {event_count / elapsed:.0f} events/sec")


if __name__ == "__main__":
    main()
